1.	合并2个递增有序链表
	将2个递增的有序链表合并为一个链表的有序链表; 要求结果链表仍然使⽤用两个链表的存储空间,不另外占用其他的存储空间. 表中不允许有重复的数据
	思路：	
		定义3个指针，p1,p2，p3,分别在 1，2，1 的头结点，分别取12，的值对比取出最小值，然后放置在p3
2.	求2个链表交集
	已知两个链表A和B分别表示两个集合.其元素递增排列。设计一个算法,用于求出A与B的交集,并存储在A链表中
	思路：
		定义3个指针，分别遍历1，2,比较12，中有相等的值就放在3指针中
3.	反转链表
	将链表中所有节点的链接⽅向"原地旋转",即要求仅利⽤原表的存储空间
	思路：（迭代插头法）
		定义一个虚拟的头，取出每个数，插入到最前面，一直迭代即可
4.	删除链表指定范围的结点
	设计一个算法,删除递增有序链表中值大于等于mink且小于等于maxk(mink,maxk是给定的两个参数,其值可以和表中的元素相同,也可以不同)的所有元素
	思路：
		（迭代法）定义2个指针，遍历找到min，max，把min的next指向max的next,再处理prev即可，
		（栈方法）讲不满足条件的数据压栈，结束后，再重新构建这个链表
5.	左移数组
	设将n(n>1)个整数存放到⼀维数组R中, 试设计一个在时间和空间两方面都尽可能高效的算法;将R中保存的序列循环左移p个位置(0<p<n)个位置, 即将R中的数据由(x0,x1,......,xn-1)变换为 (xp,xp+1,...,xn-1,x0,x1,...,xp-1)
	类似[0,1,2,3,4,5,6,7,8,9], n = 10,p = 3； 解出：[3,4,5,6,7,8,9,0,1,2]
	思路：
		while循环反转数组3次，先全部反转，再反转0-p,再反转p-(n-1)
6.	求主元素
	已知⼀个整数序列A = (a0,a1,a2,...an-1),其中(0<= ai <=n),(0<= i<=n). 若存在ap1= ap2 = ...=apm = x,且m>n/2(0<=pk<n,1<=k<=m),则称x 为 A的主元素. 例如,A = (0,5,5,3,5,7,5,5),
	则5是主元素; 若B = (0,5,5,3,5,1,5,7),则A 中没有主元素,假设A中的n个元素保存在一个一维数组中,请设计一个尽可能高效的算法,找出数组元素中的主元素,若存在主元素则输出该元素,否则输出-1
	意思：主元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
	思路：
		（摩尔投票算法）
		维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；
		遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：
		如果 x 与 candidate 相等，那么计数器 count 的值增加 1；
		如果 x 与 candidate 不等，那么计数器 count 的值减少 1。
		在遍历完成后，candidate 即为整个数组的众数。
		遍历数组中，candidate出现的次数是否大于n / 2，大于返回candidate ，否则返回-1
		（hashmap的方式实现）
7.	删除链表中所有[绝对值]重复的元素
	单链表保存m个整数, 结点的结构为(data,link),且|data|<=n(n为正整数). 现在要去设计⼀个时间复杂度尽可能⾼效的算法. 对于链表中的data 绝对值相等的结点, 仅保留第⼀次出现的结点,⽽删除其余绝对值相等的结点
	思路：
		（栈实现）存栈，满足条件的不加入栈中，后面在重组链表
		（数组实现）满足条件就记录1，不满足就记录0，后面把1的数据剔除，2次遍历
8.	兔子问题
	有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问n个月的兔子总数为多少？
	斐波那契数列，线性递增，F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*），递归
	结果：	int Fbi(int n){
				if(n<2)
					return n == 0?0:1;
				return Fbi(n-1)+Fbi(n-2);
			}
9.	汉诺塔问题
	3个柱子，n盘子，移动A->c ; 规则：1.	每次移动一个 2.	只能叠大，
	思路：
		递归法， n=1 a->c
				n>1 ,把n-1盘子 ，从A->B ，最大A->C ,再B->C
	解法：
		if(n==1) moves(A, 1, C);
		else{
			Hanoi(n-1, A, C, B);
			moves(A, n, C);
			Hanoi(n-1, B, A, C);
		}
10.	有效的括号
	给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效
	思路：
		（栈结构）解决，匹配到符号就弹出它
11.	每日气温
	根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数
	类似输入: [73, 74, 75, 71, 69, 72, 76, 73]；	输出: [1, 1, 4, 2, 1, 1, 0, 0]
	思路：
		（栈结构）大于就出栈小的数，小于就入栈
12.	爬楼梯问题
	正在爬楼梯。需要 n 阶到达楼顶，每次你可爬 1 或 2 个台阶。你有多少种不同的方法可爬到楼顶？
	思路：
		爬n阶楼梯为（n-1）和（n-2）阶的和，可联想到 斐波那契数列,因此可以使用递归法解决这个问题
		可用一个数组缓存值，最后返回数组.
		复杂度O(n),f(n) = f(n-1) + f(n-2)
13.	去除重复字母
	思路：
		先用haspMap统计字符和出现的次数
		（栈解决）没有字符就压栈，压栈判断栈里面有无此字符，有就需要移除旧的再压栈
14.	字符串解码
	编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数
	类似：
		s = "3[a]2[bc]", 返回 "aaabcbc".
		s = "3[a2[c]]", 返回 "accaccacc".
		s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".
	思路：
	（栈解决）遍历字符，将非]字符入栈。
			遇到]后，循环出栈直到[,将中间的字母字符串缓存。
			继续循环出栈[前的数字，遇到非数组结束，将数字和缓存的字母字符串解码，将其入栈。
			循环上述操作，至字符串遍历结束
15.	跳跃游戏
	非负整数数组，你位于数组第一个位（元素代表你可跳跃长度）能够到达最后一个位置
	类似：
		1>	输入: [2,3,1,1,4]
			输出: true
			解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
		2>	输入: [3,2,1,0,4]
			输出: false
			解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
	思路：
		根据贪心的策略，记录可以跳跃的最远位置，是为最优解。
		遍历至数组倒数第二个索引，在遍历中当前索引位置可以跳跃的最远长度是否大于当前记录的最远跳跃位置，若可以则更新可以跳跃的最远长度。
		判断最终可以跳跃的最远长度 是否大于等于当前数组最后位置的索引（也就是数组长度-1）。
	解析：
		bool canJump(int* nums, int numsSize){
			 int maxLength = 0;
			 for (int i = 0; i <numsSize - 1;i++){
				 if(i <= maxLength){
					 if(maxLength < i + nums[i]){
						 maxLength = i + nums[i];
					 }
				 }
			 }
			 return  maxLength >= numsSize - 1;
		}
16.	杨辉三角
	给定一个非负整数 numRows，生成杨辉三角的前 numRows 行
	如：
		输入: 5
		输出:
		[
			 [1],
			[1,1],
		   [1,2,1],
		  [1,3,3,1],
		 [1,4,6,4,1]
		]
	解法：
		动态规划法，根据每上一层的值，得到当前行对应的值 [i][j] = [i-1][j-1] + [i-1][j]
		第一层循环控制行数i : 默认[i][0] = 1,[i][i] = 1
		第二层循环控制列数j : triangle[i][j] = triangle[i-1][j-1] + triangle[i-1][j]
		按照公式直接遍历解决
17.	字符串匹配
	有主串S="abcacabdc"，模式串T="abd"，请找出模式串在主串中第一次出现的位置。提示：主串和模式串均为小写字母且都是合法输入
	解法：
		（暴力法-BF算法）直接匹配s中的第一个字符与t中的第一个字符，相等就继续判断，不相等就取s中第2个字符继续匹配
		（跳跃法-Sunday算法）判断s中与t中字符有temp个已经比较了，且不相等，下一次检查是index=s[i]+temp开始检查
		（RK算法）检查想通长度的s字符串的hash值，如果相等，就继续判断字符是否相等，否则继续判断
		（kmp算法）	求导Next数组
					声明两个变量 索引k 与 临时记录相同前缀与后缀字符个数j, next[0] = 0；
					k 在 1 < k < TLen 内做递增循环。当 T[j] != T[k] 并且 j > 0 时, j = next[j - 1],直到 j = 0 || T[j] = T[k]循环截止;
					当T[j] = T[k] 时， j++;
					next[k] = j。
					根据Next数组信息，进行主串与模式串的匹配。

					声明两个变量 i 与 j，分别记录主串T访问索引与 模式串T访问索引;
					i 在 0 < i < SLen 内递增循环。当j > 0 并且 S[i]!=T[j] 时 , j = next[j - 1]，直到 j = 0 || S[i] = T[j]循环截止;
					当S[i] = T[j] 时， j++;
					若j = TLen, 已匹配到对应字符串，否则 返回-1