一.	判断动态规划
	1.	数学优化的方法——最优子结构
		问题最优解，而一个问题的最优解是由它的各个子问题的最优解决定的
		一般是推导出一个状态转移方程 f(n)，就能很快写出问题的递归实现方法
	2.	编程的方法——重叠子问题
		借助编程的技巧去保证每个重叠的子问题只会被求解一次
	
		动态规划需要同时满足两个重要的属性：最优子结构和重叠子问题
		判断是否符合动态规划如下几个列子：
		1>	举例1
			斐波那契数列问题
			为了求出第 5 个斐波那契数，得先求出第 4 个和第 3 个数，但是在求第 4 个数的时候，又得重复计算一次第 3 个数，同样，对于第 2 个数的计算也出现了重复
		2>	举例2
			a   -   b
			|		|
			d	-	c
			a->c最长路径
			
			明显 abc,adc
			如果是a-b ，adcb
			如果是b-c ，badc
			组合 adcbadc, 明显就不对，所以不是最优子结构，就不是动态规划问题
		3>	举例3
			归并排序和快速排序是否属于动态规划？
			1>	排序分2半，归并处理，满足最优子结构
			2>	不断对排序拆半，2边数据不重叠，无重叠子数组，不满足重叠子问题
			因此不是动态规划
	3.	实例1
		LeetCode 第 300 题：给定一个无序的整数数组，找到其中最长子序列长度
		说明：
			可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
			你算法的时间复杂度应该为 O(n2） 。
		示例
			输入：[ 10, 9, 2, 5, 3, 7, 101, 18 ]
			输出：4 
			即，最长的上升子序列是 [2, 3, 7, 101]，它的长度是 4。
	4.	思路
		1.	暴力法
			罗列所有非空子数组：n×(n + 1)/2 种，即 O(n2)，非空子序列有 2n−1 种。复杂度将是 O(2n)
		2.	缩小问题规模
			1>	找最优子结构：输入规模对半分
				拆开10, 9, 2, 5] 最长的子序列应该是 [2, 5]，而 [3, 7, 101, 4] 最长的子序列是 [3, 7, 101]，由于 3 比 5 小，导致无法重新组合在一起哦了，所以废弃
			2>	找最优子结构：每次减一个
				从最后的数开始找最长子序列，最后是4，则是24，34，如果最后的不是最长子序列，就从n-1,...开始找
				此解法可以解出问题答案，但是有2个难点：
				1.	如何定义 f(n)
					对于这道题而言，f(n) 是以 nums[n−1] 结尾的最长的上升子序列的长度
				2.	得出状态转移方程
					f(n)=max (1 <= i < n−1, nums[i−1] < nums[n−1]) { f(i) } + 1
			3>	重叠子结构
				在找每个数前面的小的数的时候，会找到比他小的数，就是一个重叠的问题
			总结就是可以使用动态规划解决此问题
	5.	递归
		用递归的方法求解状态转移方程式 f(n)=max (1 <= i < n−1, nums[i−1] < nums[n−1]) { f(i) } + 1。
			对于每个 n，要从 0 开始遍历
			在 n 之前，找出比 nums[n−1] 小的数
			递归地调用 f 函数，找出最大的，最后加上 1
			当 i 等于 0 的时候，应该返回 0；当 i 等于 1 的时候应该返回 1
		代码：
		class LISRecursion {
		    // 定义一个静态变量 max，用来保存最终的最长的上升子序列的长度
		    static int max;

		    public int f(int[] nums, int n) {
		        if (n <= 1) {
		            return n;
		        }
		    
		        int result=0, maxEndingHere=1;
		    
		        // 从头遍历数组，递归求出以每个点为结尾的子数组中最长上升序列的长度
		        for (int i=1; i < n; i++) {
		            result=f(nums, i);

		            if (nums[i−1] < nums[n−1] && result + 1 > maxEndingHere) {
		                maxEndingHere=result + 1;
		            }
		        }

		        // 判断一下，如果那个数比目前最后一个数要小，那么就能构成一个新的上升子序列 
		        if (max < maxEndingHere) {
		            max=maxEndingHere;
		        }

		        // 返回以当前数结尾的上升子序列的最长长度
		        return maxEndingHere;
		    }

		    public int LIS(int[] nums) {
		        max=1;
		        f(nums, nums.length);
		        return max; 
		    }
		}
		其中，实现状态转移方程，即 f 函数。
			最基本的情况，当数组的长度为 0 时，没有上升子序列，当数组长度为 1 时，最长的上升子序列长度是 1。
			maxEndingHere 变量的含义就是包含当前最后一个元素的情况下，最长的上升子序列长度
	6.	时间复杂度
		公式法：
			n=1 O（1）
			n=2 T（1）
			n=3 T(1)+T(2)
			得出 T(n)=2×T(n−1)， O(2n)
	7.	记忆化
		递归有重复，避免重复最好就是记忆化
		记忆化，就是将已经计算出来的结果保存起来，那么下次遇到相同的输入时，直接返回保存好的结果，能够有效节省了大量的计算时间
	8.	代码：
		class LISMemoization {
		    static int max;	
		    // 定义哈希表 cache，用来保存计算结果
		    static HashMap<Integer, Integer> cache;
		    
		    // 调用递归函数的时候，判断 cache 里是否已经保留了这个值。是，则返回；不是，继续递归调用
		    public int f(int[] nums, int n) {
		        if (cache.containsKey(n)) {
		            return cache.get(n);
		        }
		        if (n <= 1) {
		            return n;
		        }

		        int result=0, maxEndingHere=1; 
		        for (int i=1; i < n; i++) {
		            ...
		        }
		    
		        if (max < maxEndingHere) {
		            max=maxEndingHere;
		        }
		    
		        // 在返回当前结果前，保存到 cache
		        cache.put(n, maxEndingHere);
		        return maxEndingHere;
		    }
		}
	9.	时间复杂度
		遍历n个值，比较n个值就是 O(T(n))=O(T(1) + T(2) + … + T(n−1))=O(1 + 2 + …. + n−1)=O(n×(n−1)/2)=O(n2)
		缓存的值，取出就是n 即 O(f(n))=O(n) + O(n^2)=O(n2)
		总结，通过记忆化，就把算法从2n减少到n2 
		这种将问题规模不断减少的做法，被称为自顶向下的方法，但是因为递归存在，工作中不推荐，最好还是自底向上
	10.	自底向上
		自底向上指，通过状态转移方程，从最小的问题规模入手，不断地增加问题规模，直到所要求的问题规模为止。依然使用记忆化避免重复的计算，不需要递归
		class LISDP {
		    public int LIS(int[] nums, int n) {
		        int[] dp=new int[n]; // 一维数组 dp 存储计算结果
		        int i, j, max=0;
		    
		        // 初始化 dp 数组里的每个元素的值为 1，即以每个元素作为结尾的最长子序列的长度初始化为 1
		        for (i=0; i < n; i++) dp[i]=1;

		        // 自底向上地求解每个子问题的最优解
		        for (i=0; i < n; i++) {
		            // 遍历中遇到的每个元素 nums[j] 与 nums[i] 比较，若 nums[j] < nums[i]，说明 nums[i] 有机会构成上升序列，若新的上升序列比之前计算过的还要长，更新一下，保存到 cache 数组
		            for (j=0; j < i; j++) {
		                if (nums[j] < nums[i] && dp[i] < dp[j] + 1) {
		                    dp[i]=dp[j] + 1;
		                }
		            }
		            // 用当前计算好的长度与全局的最大值进行比较  
		            max=Math.max(max, dp[i]);
		        }
		        // 最后得出最长的上升序列的长度
		        return max;  
		    }
		}
		这是一个双重循环，O(1 + 2 + .. + n−1)=O(n×(n−1) / 2)=O(n2)
二.	动态规划面试题分类
	运用动态规划去解决问题，最难的地方有两个：
	1>	应当采用什么样的数据结构来保存什么样的计算结果
	2>	如何利用保存下来的计算结果推导出状态转移方程
	第一个难点，不仅避免重复，也是推导状态转移方程的关键，难点往往是在把问题规模缩小的过程中进行的
	解决技巧：假设已经把所有子问题的最佳结果都计算出来了，那么只需要考虑，如何根据这些子问题的结果来得出最终的答案
	根据动态规划分3类
	1.	线性规划
		子问题线性分布，最佳结果存储一维数组，hash表中
		解法中一般用dp[i]表示第i个位置结果，一般有2种形式
		1>	求解dp[i]形式一：
			当前值仅仅依赖有限个先前计算好的值，dp[i]仅仅依赖有限dp[j],其中j<i
			1.	举例1：	斐波那契数列
				解法:	dp[i]=dp[i−1] + dp[i−2]，可以看到，当前值只依赖于前面两个计算好的值
				建议：	LeetCode 第 70 题（爬楼梯）就是一道求解斐波那契数列的题目。
			2.	LeetCode第 198 题，给定一个数组，不能选择相邻的数，求如何选才能使总数最大。
				解法：	选择i数，则  dp[i−2] + nums[i]
						不选，dp[i]=max(nums[i] + dp[i−2], dp[i−1])
				public int rob(int[] nums) {
				    int n = nums.length;
				  
				    // 处理当数组为空或者数组只有一个元素的情况
				    if(n == 0) return 0;
				    if(n == 1) return nums[0];

				    // 定义一个 dp 数组，dp[i] 表示到第 i 个元素为止我们所能收获到的最大总数
				    int[] dp = new int[n];

				    // 初始化 dp[0]，dp[1]
				    dp[0] = nums[0];
				    dp[1] = Math.max(nums[0], nums[1]);

				    // 对于每个 nums[i]，考虑两种情况，选还是不选，然后取最大值
				    for (int i = 2; i < n; i++) {
				        dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);
				    }
				  
				    return dp[n - 1];
				}
			3.	一个机器人位于一个 网格的左上角（起始点在下图中标记为“Start”）。机器人每次只能向下或向右移动一步。机器人试图到达网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？
				说明： 和的值均不超过100。
				解法1：	暴力法
				解法2：	减少问题规模
						分别计算走到它上面的格子以及左边的格子的步数，相加。递推公式为 dp[i][j]=dp[i−1][j] + dp[i][j−1]
				虽然利用一个二维数组去保存计算的结果，但是 dp[i][j] 所表达的意思仍然是线性的，dp[i][j] 表示从起点到 (i, j) 的总走法。本题不再讨论具体实现。可以看到，dp[i][j] 仅仅依赖于两个先前的状态
		1>	求解dp[i]形式二：	
			当前所求的值依赖于所有先前计算好的值，也就是说，dp[i] 是各个 dp[j] 的某种组合，其中 j 由 0 遍历到 i−1
			举例：	求解最长上升子序列
			解法：	dp[i]=max(dp[j]) + 1，0 <= j < i。可以看到，当前值依赖于前面所有计算好的值
				
	2.	区间规划：
		区间规划，就是说各个子问题的规模由不同的区间来定义，一般子问题的最佳状态或结果存储在二维数组里。一般用 dp[i][j] 代表从第 i 个位置到第 j 个位置之间的最佳状态或结果
		解这类问题的时间复杂度一般为多项式时间，对于一个大小为 n 的问题，时间复杂度不会超过 n 的多项式倍数。例如，O(n)=n^k，k 是一个常数，根据题目的不同而定
		1>	举例：LeetCode 第 516 题，在一个字符串 S 中求最长的回文子序列。例如给定字符串为 dccac，最长回文就是 ccc
			解法一：	
			dp[i][j] 表示从字符串第 i 个字符到第 j 个字符之间的最长回文，最长会保存在 dp[0][n−1] 
			当首尾的两个字符相等的时候 dp[0][n−1]=dp[1][n−2] + 2，
			否则，dp[0][n−1]=max(dp[1][n−1], dp[0][n−2])
			代码实现：
			public static int LPS(String s) {
			    int n = s.length();
			    // 定义 dp 矩阵，dp[i][j] 表示从字符串第 i 个字符到第 j 个字符之间的最长回文
			    int[][] dp = new int[n][n];
			  
			    // 初始化 dp 矩阵，将对角线元素设为 1，即单个字符的回文长度为 1
			    for (int i = 0; i < n; i++) dp[i][i] = 1;
			  
			    // 从长度为 2 开始，尝试将区间扩大，一直扩大到 n
			    for (int len = 2; len <= n; len++) {
			        // 在扩大的过程中，每次都得出区间的其实位置i和结束位置j
			        for (int i = 0; i < n - len + 1; i++) {
			            int j = i + len - 1;
			      
			            // 比较一下区间首尾的字符是否相等，如果相等，就加2；如果不等，从规模更小的字符串中得出最长的回文长度
			            if (s.charAt(i) == s.charAt(j)) {
			                dp[i][j] = 2 + (len == 2 ? 0: dp[i + 1][j - 1]);
			              } else {
			                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
			              }
			        }
			    }
			  
			    return dp[0][n - 1];
			}
			解法二：
			
	3.	线性约束
		
三.	总结
	线性规划，主要是多练