一.	基本排序
	稳定性：	是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变
	1.	冒泡
		1>	思想
			给定一个数组，我们把数组里的元素通通倒入到水池中，这些元素将通过相互之间的比较，按照大小顺序一个一个地像气泡一样浮出水面
		2>	实现
			每一轮，从杂乱无章的数组头部开始，每两个元素比较大小并进行交换，直到这一轮当中最大或最小的元素被放置在数组的尾部，然后不断地重复这个过程，直到所有元素都排好位置。其中，核心操作就是元素相互比较
		3>	例题分析
			给定数组 [2, 1, 7, 9, 5, 8]，要求按照从左到右、从小到大的顺序进行排序。 
		4>	解析
			void sort(int[] nums) {
			    //定义一个布尔变量 hasChange，用来标记每轮遍历中是否发生了交换
			    boolean hasChange = true; 

			    //每轮遍历开始，将 hasChange 设置为 false
			    for (int i = 0; i < nums.length - 1 && hasChange; i++) {
			        hasChange = false;

			        //进行两两比较，如果发现当前的数比下一个数还大，那么就交换这两个数，同时记录一下有交换发生
			        for (int j = 0; j < nums.length - 1 - i; j++) {
			            if (nums[j] > nums[j + 1]) {
			                swap(nums, j, j + 1);
			                hasChange = true;
			            }
			        }
			     }
			 }
		5>	分析
			空间复杂度：由于是22交换就是O(1)
			时间复杂度：o(n2)，（正序:无比较，遍历n次 o(n),逆序：n次比较，n次遍历，O(n2),无序：O(n2);总结：o(n2)）
			是稳定算法
	2.	插入
		1>	思想
			不断地将尚未排好序的数插入到已经排好序的部分
		2>	实例
			对数组 [2, 1, 7, 9, 5, 8] 进行插入排序。
		3>	思路
			1.	先来看 1，由于 1 比 2 小，需要将 1 插入到 2 的前面，做法很简单，两两交换位置即可，[1, 2, 7, 9, 5, 8]。
			2.	然后，我们要把 7 插入到左边的部分，由于 7 已经比 2 大了，表明它是目前最大的元素，保持位置不变，[1, 2, 7, 9, 5, 8]。
			3.	同理，9 也不需要做位置变动，[1, 2, 7, 9, 5, 8]。
			4.	接下来，如何把 5 插入到合适的位置。首先比较 5 和 9，由于 5 比 9 小，两两交换，[1, 2, 7, 5, 9, 8]，继续，由于 5 比 7 小，两两交换，[1, 2, 5, 7, 9, 8]，最后，由于 5 比 2 大，此轮结束。
			5.	最后一个数是 8，由于 8 比 9 小，两两交换，[1, 2, 5, 7, 8, 9]，再比较 7 和 8，发现 8 比 7 大，此轮结束。到此，插入排序完毕
		4>	解析
			void sort(int[] nums) {
			    // 将数组的第一个元素当作已经排好序的，从第二个元素，即 i 从 1 开始遍历数组
			    for (int i = 1, j, current; i < nums.length; i++) {
			        // 外围循环开始，把当前 i 指向的值用 current 保存
			        current = nums[i];

			        // 指针 j 内循环，和 current 值比较，若 j 所指向的值比 current 值大，则该数右移一位
			        for (j = i - 1; j >= 0 && nums[j] > current; j--) {
			            nums[j + 1] = nums[j];
			            }
			    
			        // 内循环结束，j+1 所指向的位置就是 current 值插入的位置
			        nums[j + 1] = current;
			    }
			}
		5>	分析
			空间复杂度：22交换，O(1)
			时间复杂度：o(n2)，（正序:无比较，遍历n次 o(n),逆序：n次比较，n次遍历，O(n2),无序：O(n2);总结：o(n2)）
			是稳定算法
		6>	leecode 147题，要求对一个链表进行插入排序
二.	常考排序
	1.	归并
		1>	思想
			核心是分治，就是把一个复杂的问题分成两个或多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。归并排序将分治的思想体现得淋漓尽致
		2>	实现
			一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。
			排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好
		3>	解析
			void sort(int[] A, int lo, int hi) {
			  // 判断是否只剩下最后一个元素
			  if (lo >= hi) return;
			  
			  // 从中间将数组分成两个部分
			  int mid = lo + (hi - lo) / 2;
			  
			  // 分别递归地将左右两半排好序
			  sort(A, lo, mid);
			  sort(A, mid + 1, hi);

			  // 将排好序的左右两半合并  
			  merge(A, lo, mid, hi);
			}
			void merge(int[] nums, int lo, int mid, int hi) {
			    // 复制一份原来的数组
			    int[] copy = nums.clone();
			  
			    // 定义一个 k 指针表示从什么位置开始修改原来的数组，i 指针表示左半边的起始位置，j 表示右半边的起始位置
			    int k = lo, i = lo, j = mid + 1;
			  
			    while (k <= hi) {
			        if (i > mid) {
			            nums[k++] = copy[j++];
			        } else if (j > hi) {
			          nums[k++] = copy[i++];
			        } else if (copy[j] < copy[i]) {
			          nums[k++] = copy[j++];
			        } else {
			          nums[k++] = copy[i++];
			        }
			    }
			}
		其中，While 语句比较，一共可能会出现四种情况。
			左半边的数都处理完毕，只剩下右半边的数，只需要将右半边的数逐个拷贝过去。
			右半边的数都处理完毕，只剩下左半边的数，只需要将左半边的数逐个拷贝过去就好。
			右边的数小于左边的数，将右边的数拷贝到合适的位置，j 指针往前移动一位。
			左边的数小于右边的数，将左边的数拷贝到合适的位置，i 指针往前移动一位。
		4>	分析
			空间复杂度：O(n)
			时间复杂度：O(nlogn)【二分复杂度2个2*T(n/2)，加上最后合并比较n次O(n)，总结就是2*T(n/2)+O(n)，缩略就是O(nlogn)】
		5>	牢记对2个数组有序合并的思想
	2.	快速
		1>	思想
			采用了分治思想
		2>	实现
			把原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。
		3>	举例
			把班里的所有同学按照高矮顺序排成一排。
		4>	解法
			老师先随机地挑选了同学 A，让所有其他同学和 A 比高矮，比 A 矮的都站在 A 的左边，比 A 高的都站在 A 的右边。接下来，老师分别从左边和右边的同学里选择了同学 B 和 C，然后不断地筛选和排列下去。
			在分成较小和较大的两个子数组过程中，如何选定一个基准值（也就是同学 A、B、C 等）尤为关键。
		5>	实例
			对数组 [2, 1, 7, 9, 5, 8] 进行排序
		6>	解题思路
			按照快速排序的思想，首先把数组筛选成较小和较大的两个子数组。
			随机从数组里选取一个数作为基准值，比如 7，于是原始的数组就被分成了两个子数组。注意：快速排序是直接在原始数组里进行各种交换操作，所以当子数组被分割出来的时候，原始数组里的排列也被改变了。
			接下来，在较小的子数组里选 2 作为基准值，在较大的子数组里选 8 作为基准值，继续分割子数组。
			继续将元素个数大于 1 的子数组进行划分，当所有子数组里的元素个数都为 1 的时候，原始数组也被排好序了
		7>	解析
			void sort(int[] nums, int lo, int hi) {
			    if (lo >= hi) return; // 判断是否只剩下一个元素，是，则直接返回
			    
			    // 利用 partition 函数找到一个随机的基准点
			    int p = partition(nums, lo, hi);
			    
			    // 递归地对基准点左半边和右半边的数进行排序
			    sort(nums, lo, p - 1);
			    sort(nums, p + 1, hi);
			}
			int partition(int[] nums, int lo, int hi) {
			    // 随机选择一个数作为基准值，nums[hi] 就是基准值
			    swap(nums, randRange(lo, hi), hi);

			    int i, j;

			    // 从左到右用每个数和基准值比较，若比基准值小，则放到指针 i 所指向的位置。循环完毕后，i 指针之前的数都比基准值小
			    for (i = lo, j = lo; j < hi; j++) {
			        if (nums[j] <= nums[hi]) {
			            swap(nums, i++, j);
			        }
			    }

			    // 末尾的基准值放置到指针 i 的位置，i 指针之后的数都比基准值大
			    swap(nums, i, j);

			    // 返回指针 i，作为基准点的位置
			    return i;
			}
		8>	分析
			空间复杂度：O(logn)
			时间复杂度：最好的情况（被选出来的基准值都是当前子数组的中间数。），O(nlogn)，
						最坏的情况(基准值选择了子数组里的最大或者最小值),O(n2)
		9>	leecode 第 215 题，给定一个尚未排好序的数组，要求找出第 k 大的数。
			解法：
				1 直接排序
				2 快速排序，对基准值分，检查基准值是不是k即可，复杂度O(n)
	3.	拓扑
		1>	思想
			图里面的顶点和连线的关系
			前提 （1）图必须是有向图 （2）图里面没有环
			一般用来理清具有依赖关系的任务
		2>	实例
			三门课程 A、B、C，想学习 C 必须学完 B ，想学习 B必须学完 A，所以顺序是A->B->C
		3>	实现
			先抽象表达出来哪些是图顶点，顶点之间怎么关联，
			可利用广度优先搜索或深度优先搜索来进行拓扑排序
		4>	实例
			有2门课程，1、2、3、4、5
				课程 2 和 4 依赖于课程 1
				课程 3 依赖于课程 2 和 4
				课程 4 依赖于课程 1 和 2
				课程 5 依赖于课程 3 和 4
			应该怎么学习
		5>	思路
			根据规则画出每个点的关系，然后根据入度（前驱）得出;(0)，2(1)，3(2)，4(1)，5(2)
			接着依次遍历删除没有前驱的点，1，2，4，3，5
		6>	解析
			利用广度优先搜索遍历
			void sort() {
			    Queue<Integer> q = new LinkedList(); // 定义一个队列 q

			    // 将所有入度为 0 的顶点加入到队列 q
			    for (int v = 0; v < V; v++) {
			        if (indegree[v] == 0) q.add(v);
			    }

			    // 循环，直到队列为空
			    while (!q.isEmpty()) {
			        int v = q.poll();
			        // 每次循环中，从队列中取出顶点，即为按照入度数目排序中最小的那个顶点
			        print(v);

			        // 将跟这个顶点相连的其他顶点的入度减 1，如果发现那个顶点的入度变成了 0，将其加入到队列的末尾
			        for (int u = 0; u < adj[v].length; u++) {
			            if (--indegree[u] == 0) {
			                q.add(u);
			            }
			        }
			    }
			}
		7>	分析
			时间复杂度：统计顶点O(n),接下来每个顶点遍历一次O(n),总结就是O(n)
三.	其他排序
	1.	堆排序
		创建最大堆
	2.	桶排序
	
四.	拓展排序
	1.	希尔排序（缩小增量排序）
		按照间隔n个增量差分数据，在堆子数据插入排序
	2.	计数排序
		将输入的数据值转化为键存储在额外开辟的数组空间中，且输入的数据必须有确定性
	3.	桶排序
		将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）
	4.	基数排序
		基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前
		假如是38，就先收集3这种，个位，十位分别排序
		
		
	
	