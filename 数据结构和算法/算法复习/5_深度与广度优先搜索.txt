一.	深度优先搜索（DFS）
	原理：	从起点出发，从一个方向走，直到停止，然后尝试走另一个方向，直到终点
	DFS遍历：假设我们有这么一个图，里面有A、B、C、D、E、F、G、H 8 个顶点，点和点之间的联系如下图所示，对这个图进行深度优先的遍历
		b  ------  f --------- c
	  |	  |			| 			|
	  |	   a   ----  d			H
	  E		|
	   |	|
		  G
	解题思路：	依赖栈实现，访问一个就加入栈，直到无法访问就搜索栈顶附近有无点，没有就弹栈，一直弹，再搜索附近有无有就继续压栈
				（搜索顺序是按照字母的顺序执行）
	1.	列一：	给定一个二维矩阵代表一个迷宫，迷宫里面有通道，也有墙壁，通道由数字 0 表示，而墙壁由 -1 表示，有墙壁的地方不能通过，那么，能不能从 A 点走到 B 点
		代码实现：数组使用二维数组来表示：  2种实现都在解法中
		思路：
			递归实现：
				代码看上去很简洁；
				实际应用中，递归需要压入和弹出栈，栈深的时候会造成运行效率低下
			非递归实现：
				栈支持压入和弹出；
				栈能提高效率。
		算法分析：
			一般dfs使用图论思想，图两种表示方式：邻接表、邻接矩阵
		时间复杂度：
			邻接表
				访问所有顶点的时间为 O(V)，而查找所有顶点的邻居一共需要 O(E) 的时间，所以总的时间复杂度是 O(V + E)。
			邻接矩阵
				查找每个顶点的邻居需要 O(V) 的时间，所以查找整个矩阵的时候需要 O(V2) 的时间。
		举例：	利用 DFS 在迷宫里找一条路径的复杂度。迷宫是用矩阵表示。
			时间复杂度：	看成邻接矩阵，m行n列，顶点就是mxn个，复杂度：O(MxN)
			控件复杂度：	堆栈解决，最坏就是全部压栈，复杂度：O(MxN)
	2.	列2：	利用 DFS 去寻找最短的路径
		思路：
			1>	暴力法：	找所有离开，比较长短，
			2>	优化法：	寻找目的地，并记录到起始点距离，从某方向到达距离最少就更新，到达距离多就不尝试
		代码实现：	
		运行结果：
		
二.	广度优先搜索（BFS）
	1.	思想
		广度优先搜索，一般用来解决最短路径的问题。和深度优先搜索不同，广度优先的搜索是从起始点出发，一层一层地进行，每层当中的点距离起始点的步数都是相同的，当找到了目的地之后就可以立即结束
		而且还可以同时进行，双端 BFS
	2.	解法
		只从一个方向进行 BFS，有时候这个人认识的朋友特别多，那么会导致搜索起来非常慢；
		如果另外一方认识的人比较少，从这一方进行搜索，就能极大地减少搜索的次数；
		每次在决定从哪一边进行搜索的时候，要判断一下哪边认识的人比较少，然后从那边进行搜索。
	3.	BFS遍历：假设我们有这么一个图，里面有A、B、C、D、E、F、G、H 8 个顶点，点和点之间的联系如下图所示，对这个图进行深度优先的遍历
		b  ------  f --------- c
	  |	  |			| 			|
	  |	   a   ----  d			H
	  E		|
	   |	|
		  G
		需要队列解决，先进先出
		依靠字母的顺序，一层层的加入到队列中，再从队列中取数据判断（如果有数据就不需要加入队列）
	4.	迷宫问题
		解法如下
	5.	算法分析
		时间复杂度：
			邻接表：
				每个顶点访问一次O(V),相连顶点访问一次O(E),整体时间复杂度O(V+E)
			邻接矩阵:
				v个顶点，O(V2)
		迷宫如果是邻接矩阵解决，m行n列，时间复杂度O(MxN)
		空间复杂度：
			借助队列，每次入队出队，O(Mxn)
	6.	列2
		A->B，可打通3个墙，求最短路径
	7.	思路
		1.	暴力法
			总共有4总办法，不拆，拆1，拆2，拆3
			组合：C(K, 0) + C(K, 1) + C(K, 2) + C(K, 3) = 1 + K + K ×(K - 1) / 2 + K× (K - 1) ×(K - 2) / 6
			k3,如果打通墙数量是w，就是kw
		2.	BFS
			整体BFS，时间复杂度就是 O(n2×Kw)，明显不行
			1>将 BFS 的数量减少。
				在不允许打通墙的情况下，只有一个人进行 BFS 搜索，时间复杂度是 n2；
				允许打通一堵墙的情况下，分身为两个人进行 BFS 搜索，时间复杂度是 2×n2；
				允许打通两堵墙的情况下，分身为三个人进行 BFS 搜索，时间复杂度是 3×n2；
				允许打通三堵墙的情况下，分身为四个人进行 BFS 搜索，时间复杂度是 4×n2。 
			2> 解决关键问题。
				如果第一个人又遇到了一堵墙，那么他是否需要再次分身呢？不能。
				第一个人怎么告诉第二个人可以去访问这个点？把这个点放入到队列中。
				如何让 4 个人在独立的平面里搜索？利用一个三维矩阵记录每个层面里的点。
三.	总结
	广度/深度优先，常考点，包括其之间的对比