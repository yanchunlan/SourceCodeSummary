1.	场景
	1>实例方法，作用于当前实例加锁（即当前对象），进入同步代码前要获得当前实例的锁
	2>静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁（任意多个对象，只要是这个类都能唯一）
	3>代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。
	
2.	synahroized原理：
		synchronized的对象锁（重量级锁），锁标识位为10，其中指针指向的是monitor对象，字节码层是 monitorenter  锁开始。onitorexit 锁结束
		如果是方法锁，则 ACC_SYNCHRONIZED 标识区分是否同步，
	
3.	锁得状态：
		无锁，偏向锁，轻量级，重量级锁 （依次递增）
	偏向锁：
		如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同
	步操作，即获取锁的过程
	轻量级锁：
		若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段
		轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁
	自旋锁：
		轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。
		这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿
		失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来
	锁消除：
		编译前，进行扫描，把不可能存在竞争的锁，删除
		
4.	synchronized
	1>synchronized的可重入性：当前类中 synchronized 方法可以调用另一个synchronized 方法，或者子类调用父类的，都是可以的
	2>线程的中断对于synchronized是无效的
	拓展：线程的中断：interrupt可以中断阻塞的线程，未阻塞的线程，加上如下判断，
	 if (this.isInterrupted()){
        System.out.println("线程中断");
        break;
     }
	3>notify/notifyAll和wait,必须在synchronized中，因为需要拿到监视器monitor对象
	seleep与wait区别：
		wait调用，线程暂停。释放监视器锁(monitor)，直到notify/notifyAll后才能执行
		sleep仅休眠，不释放锁，notify/notifyAll后不释放锁，synchronized执行完才会释放锁
	

--------------------------
深度理解

synchronized实现原理
一.	对象头
	创建一个对象会创建一个instanceOopDesc,其父类oopDesc,其中有_Mark和_metadata一起组成对象头
	其中_Mark是markoop类型数据，也被称为标记字段mark word，主要存储了对象的hashCode,分带年龄，锁标志位，是否偏向锁

	有如下表格：

	其中锁状态也有如下表格：
		是否偏向锁	锁标记位	锁状态
		0			01		无锁
		1			01		偏向锁
		0			00		轻量级锁
		0			10		重量级锁
		0			11		GC标记

二.	Monitor
	同步工具，在markoop中有创建一个monitor就会创建一个objectMonitor,其结构如下：
	objectMonitor{
		_header		=	null
		_count		=	0 //记录个数
		_recursions	=	0; // 锁重入次数
		_owner		=	null	// 指向持有onjectMonitor对象的线程
		_waitSet	=	null	// wait线程，会被加入到waitSet
		_entryList  =	null	// 等待锁block状态线程，会被加入该列表	
	}

	流程：
		多线程访问同一段同步代码时，首先进入_entryList中,某线程获取到对象的monitor,会设置_owner为当前线程，且_count+1，
		若monitor线程调用wait方法，将释放当前monitor，_owner为null,_count-1,同时该线程进入_waitSet等待唤醒
		若当前线程执行完将释放monitor，并复位变量值，以便其他线程继续可以进入获取monitor值

	模型图如下：
	objectMonitor{    // 进入owner,count+1,退出-1
		_entryList	_owner 	WaitSet
	}

	objectMonitor同步机制是jvm对操作系统级别的互斥锁的管理过程，其间都会进入操作系统内核态，所以也是一个重量级操作

三.	java虚拟机对synchronized的优化
	1.	锁自旋
		因为线程的柱塞唤醒需要cpu频繁用户态核心态切换,所以添加自旋，
		实现方式：
			其实就是让线程等待（执行一段无意义的循环）一段时间不会立即挂起，看当前锁是否会很快释放

		缺点：白白浪费自旋占用的cpu时间，在竞争激烈情况下会导致锁持有时间长，解决措施可以禁用自旋锁
		-xx:+useSpinning 控制开闭

	2.	轻量级锁
		多线程交替请求锁对象时，即不存在锁竞争情况，会保持轻量级锁状态，减少重量级锁柱塞和唤醒
		实现方式：
			当前线程开辟空间lock record，请求同步代码时，利用cas 拷贝锁对象markword,并将当前线程锁记录的owner指向锁对象的markword,
			当再次执行同步代码块时，判断锁对象markword是否指向当前线程，若是则直接执行代码，不是则说明被其他线程抢占，升级重量级锁

		缺点：如果同一时间访问同一个锁，会导致轻量级锁升级为重量级锁

	3.	偏向锁
		总是一个线程获取到锁，为了让其更方便获取到锁，给与偏向锁，当再次访问同步代码，就不需要进行抢占锁释放锁操作了
		实现方式：
			对象头有个threadId在第一次获取锁就会将其写入锁对象markword的threadid中，并更新偏向锁状态01，下次获取锁检查threadid是否相同，相同不需要获取锁，略过轻量级锁重量级锁，直接执行

		缺点：出现锁竞争，偏向锁就会消失升级为轻量级锁

	4.	锁消除
		基于对象逃逸分析，经典就是stringBuffer的拼接

	流程：无锁 - 偏向锁 - 轻量级锁 （自旋锁，自适应自旋）- 重量级锁
四.	总结
	其实给出这么多中间状态，只是为了减少重量级锁次数，因为重量级锁通过对象内部监视器objectMonitor实现，本质依赖于底层操作系统的mutex lock，操作系统实现线程之间的切换需要从用户态到内核态的切换，成本太高。