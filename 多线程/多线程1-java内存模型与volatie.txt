一.	理解java内存区域与内存模型
	1.	java内存区域
		1）方法区，堆区，程序计数器，虚拟机栈，本地方法栈
		
		2）共享区域：方法区，堆区
		非共享区域：程序计数器，虚拟机栈，本地方法栈
		
		3）方法区：
			存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
			内部含有运行时常量池，存放编译器生成的各种字面量和符号引用
		   堆区：
			存放对象实例
		   程序计数器：
			 代表当前线程所执行的字节码行号指示器，通过改变这个计数器的值来选取字节码指令，分支、循环、跳转、异常处理、线程恢复等
		   虚拟机栈：
			  每个方法执行时都会创建一个栈桢来存储方法的的变量表、操作数栈、动态链接方法、返回值、返回地址等信息。每个方法从调用直
			  结束就对于一个栈桢在虚拟机栈中的入栈和出栈过程
		   本地方法栈：
			  虚拟机用到的 Native 方法相关
	2.	java的内存模型
		主内存存储变量，工作内存操作数据，操作完成，再讲变量写回主内存
		基本类型存储帧栈中，引用类型其引用存储在帧栈，对象实例存储在堆，但是对于实例额对象的成员变量
		都是存储在堆区		
	3.	硬件内存架构
		主内存RAM  ---  cpu缓存  ---  cpu寄存器
		当一个CPU需要访问主存时，会先读取一部分主存数据到CPU缓存(当然如果CPU缓存中存在需要的数据就会直接从
		缓存获取)，进而在读取CPU缓存到寄存器，当CPU需要写数据到主存时，同样会先刷新寄存器中的数据到CPU缓存，
		然后再把数据刷新到主内存中
	4.	java内存模型的承若
		JMM是围绕着程序执行的原子性、有序性、可见性展开的
		原子性：一个操作是不可中断的
		有序性：单线程的执行代码，认为代码的执行按顺序依次执行的
		
		拓展：
			指令重排：编译器优化的重排，指令并行重排，内存系统的重排
			a)编译器重排：排序乱套
			b)处理器重排：可能后面的指令需要时间，就会等待，那么重排就可以减少等待
			编译器重排以及处理器重排(这两种重排我们后面统一称为指令重排)
			
		可见性：当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值
		
		用法：
			可以使用synchronized，reentrantLock保证方法，代码块原子性，
			工作内存与主内存同步延迟，使用synchronized，volatile解决，
			指令重排导致的可见性和有序性，使用volatile解决，
			JMM内部还定义一套happens-before 原则来保证多线程环境下两个操作间的原子性、可见性以及有序性
	5.	happens-before 原则内容如下

		1).	程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。

		2).	锁规则 解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。

		3).	volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。

		4).	线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见

		5).	传递性 A先于B ，B先于C 那么A必然先于C

		6).	线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。

		7).	线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。

		8).	对象终结规则 对象的构造函数执行，结束先于finalize()方法
	6.	volatile 
		可见性，写一个volatile变量时，JMM会把该线程对应的工作内存中的共享变量值刷新到主内存中，当读取一个volatile变量时，JMM会把该线程对应的工作内存置为无效，那么该线程将只能从主内存中重新读取共享变量
		禁止指令重排优化，（synchronized 具备volatile效果，使用它禁止重排，就会在instance = new Instance()的时候，执行多个执行，禁止其乱序）
		总结：
			volatile保证可见性，有序性
			syncrized保证原子性