一. GlobalKey
	Element? get _currentElement => WidgetsBinding.instance!.buildOwner!._globalKeyRegistry[this];
	1. 数据获取
		其中_globalKeyRegistry是一个map类型，在三棵树挂载的时候mount就会存值（挂载流程：element通过inflateWidget->mount-> rebuild(ComponentElement) -> performRebuild (ComponentElement)-> updateChild->inflateWidget递归创建element树结构），同理获取到_currentElement后，可以获取到其他widget，state，context数据
	2. 数据状态保存
		setState流程：markNeedsBuild将当前element标记为dirty，调用owner的 scheduleBuildFor(this)将当前element添加到owner的_dirtyElements里面，调用onBuildScheduled通知drawFrame，WidgetsBinding.drawFrame -> owner.buildScope处理dirty element的rebuild，调用buildOwner!.finalizeTree来释放_inactiveElements，在element的rebuild中调用performRebuild（build -> updateChild -> deactivateChild -> inflateWidget），其中deactivateChild没有立即释放element，而是将element添加到owner的_inactiveElements，后续inflateWidget递归构建新element树时，判断是否是GlobalKey，是则_retakeInactiveElement复用取出GlobalKey对应的element。
		
	key相关类描述：
	1. LocalKey 
		ValueKey：使用特定类型的值来做标识的，值引用
		ObjectKey：对象引用
		UniqueKey：生成一个独一无二的key值
		PageStorageKey：用于保存和还原比Widget生命周期更长的值
	2. GlobalKey
		LabeledGlobalKey：带有标签的GlobalKey。 该标签仅用于调试，不用于比较
		GlobalObjectKey：对象引用
	
二. Provider
		Provider -> ChangeNotifierProvider -> ListenableProvider -> InheritedProvider -> SingleChildStatelessWidget -> 
		1. ChangeNotifierProvider
			继承ListenableProvider，有crete，value，dispose函数，其中create自动传递静态_dispose管理生命周期，value需要自己管理生命周期。
		2. InheritedProvider
			构造函数_CreateInheritedProvider/_ValueInheritedProvider，其中buildWithChild -> _InheritedProviderScope(xxx extends InheritedWidget)，
			其中是否更新updateShouldNotify，子类_InheritedProviderScope重写了createElement，在_InheritedProviderScopeElement的performRebuild中创建了_delegateState并赋值element到_Delegate，待下一次build的时候notifyClients(widget)通知刷新
			什么时候添加的监听：
				_CreateInheritedProviderState在get value的时候添加监听delegate.startListening?.call，dispose的时候delegate.dispose?.call
		总结：
			Provider.of(context) -> _inheritedElementOf获取到element -> element.value获取到Counter状态类
			当Counter.notifyListeners -> element.rebuild -> element.notifyClients通知dependOnInheritedWidgetOfExactType的context刷新
			
三. ProxyProvider（ChangeNotifierProvider类似）
		ProxyProvider -> ProxyProvider0 -> InheritedProvider -> 
		1. 获取value的时候，调用update初始化value，若为ChangeNotifierProxyProvider则有create和监听，其中startListening无效时因为ProxyProvider没有startListening方法，实现自动更新通过Counter实现，Counter.notifyListeners -> _InheritedProviderScopeElement.build -> _delegateState.build -> delegate.update更新数据
		
四. Selector 条件刷新
		Selector -> Selector0( _Selector0State.buildWithChild) -> widget.selector(context) -> Provider.of(context) 创建监听
		刷新判断：_Selector0State.buildWithChild中根据缓存旧Widget-cache、旧数据value，然后会判断widget是否相同、shouldRebuild条件、DeepCollectionEquality对比来判断是否需要更新组件

五. RepaintBoundary
	原理：包裹的子widget，单独使用一层layer去参与print，与renderView层绘制隔离开，每次帧绘制的时候，直接从RepaintBoundary控件print
	使用场景：子类有频繁绘制，或者嵌套层级较深，使用其包裹，列入：动画控件，自定义print控件
	
六. Layer
	1. 分类
		1>	PictureLayer 图像绘制 如:Text ,Image
				class PictureLayer extends Layer {
				ui.Picture? _picture;
				@override
  				void addToScene(ui.SceneBuilder builder, [ Offset layerOffset = Offset.zero ]) {
    				builder.addPicture(layerOffset, picture!, isComplexHint: isComplexHint, willChangeHint: willChangeHint);
 				 }
				}
				
				一个_picture就可以绘制一层画面，
				RenderObject绘制流程：
					1. RenderObject.paint(PaintingContext context, Offset offset)
					2. PaintingContext内部有Canvas，并含有ContainerLayer，通过paint创建了Picturelayer，会append到ContainerLayer上
					3. _startRecording 把当前的PictureLayer append到_containerLayer上
				汇总上面流程就是：
					 PaintingContext context = PaintingContext(rootLayer,Rect.fromLTRB(0, 0, 1000, 1000));  // 1. 建立rootLayer与当前Layer的关联
  					 context.canvas.drawRect(Rect.fromLTRB(200, 200, 800, 800), Paint()..color = Colors.blue); // 2. 当前Layer绘制，模拟paint方法 
  					 context.stopRecordingIfNeeded(); // 3. 当前PictureLayer添加到rootLayer
 					  final SceneBuilder builder = ui.SceneBuilder();
 					  final Scene scene = rootLayer.buildScene(builder); // 4. 合成所有layer到rootLayer
 					  ui.window.render(scene); // 5. 发送Scene数据到引擎
 					  scene.dispose(); // 释放这次的Scene数据
				
		2>	TextureLayer 外接纹理 如: 视频播放
		3>	PlatformViewLayer  Flutter嵌套Native View
		4>	PerformanceOverlayLayer 性能监控相关，能够显示出GPU对当前帧光栅化的耗时以及帧渲染的耗时
		5>	ContainerLayer 复合层  相当于一个根节点可以合成多个叶子节点的layer ，TransformLayer属于ContainerLayer的派生类
		6>	ClipPathLayer 剪裁图层，剪裁子图层【图层对的剪裁是比较消耗性能的,尽可能避免使用】
		7>	ColorFilterLayer 滤色器图层 ，色子图层
	2. 特殊的Layer
		RepaintBoundary 或者 自定义RandomColorRenderObject重写isRepaintBoundary的值
		列如：自定义设置isRepaintBoundary为true或者false，点击文字会发现返回false的时候RandomColorRenderObject的piant会被调用，而返回true的时候RandomColorRenderObject的piant不会会被调用
		使用场景：某个Layer的绘制耗时且不频繁刷新时，通过设置isRepaintBoundary为true，复用提升性能
		
七. AnimationController 动画控件
	1. vsync
		一般传入 SingleTickerProviderStateMixin，且内部执行_ticker = vsync.createTicker(_tick)，
		原理：Ticker是被SchedulerBinding所驱动。SchedulerBinding则是监听着Window.onBeginFrame回调【该提供一个scene】，简而言之就是接收一帧，就绘制一帧
