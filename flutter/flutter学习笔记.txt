一. dart特性
	1. jit和Aot
	运行时JIT即时编译，发版时AOT提前编译
	2. 内存分配和垃圾回收
	创建对象等于堆上移动指针，线性增长，不需要查找内存
	多生代回收，半空间机制，半个空间活跃的对象拷贝备用空间，然后释放当前所有空间内存
	3. 单线程模型
	没有抢占，没有锁，执有ISOlate,彼此之间不共享内存，通过looper发送消息通讯
二.	dart语言
	一切都是对象
	1. 基本类型
		num:int ,double
		bool
		String
	2. 集合
		list
		map
	3. 常量
		const 编译时
		final 运行时
	4. 函数
		{} 可选命名函数
		void method1({bool a,bool b=false})
		[] 可选参数
		void method1(bool a,[bool b=false])

		_method 函数前添加_代表私有函数 
 	5. 类
 		构造函数
 		class point{
 			Point(this.x,this.y)
 			Point(this.x,this.y):z=0;
 		}
 		继承 extend
 		接口 implements
 		复用 with
	6. 运算符
		?. 防止为null
		??= null就赋值，不为null不赋值
		？？ 等于三元运算符？：
三.	Flutter 原理
	1. 分层
		embedder: 操作系统适配层，surface设置，线程设置，平台插件等平台相关特性的适配
		engine：skia,dart,text,实现了flutter的渲染引擎，文字排版，事件处理，dart运行时功能
		framework：UI sdk，包含动画，图形绘制，手势识别等
	2. 绘制原理
		布局
			深度优先遍历渲染对象树，父对象控件逻辑决定子对象控件逻辑
			【flutter引入的一个优化】布局边界：relayout boundary 只布局自己跟子节点，不影响到外部
		绘制
			深度优先的方式，（前序遍历）绘制自己再绘制子节点
			【flutter引入的一个优化】重绘边界：repaint boundary 只绘制自己跟子节点，不绘制外部
		合成
			根据大小，层级，透明度等计算最终实际图层，相同图层合并简化图层
		渲染
			图层数据 -> skia -> 二维图像数据 -> GPU渲染
四.	flutter语言
	一切都是weight
	1. weight
		weight，element，renderObject，renderObjectWeight
		流程：
			1. 先遍历weight,调用renderObjectWeight中createElement -> 创建element
			2. 调用element（子类renderObjectElement）的mount  -> 创建renderObject
			3. 插入渲染树
		改变：
			weight改变，weight的element标记dirty,等待下一个vsync，触发element更新，并使用最新的weight数据更新自身以及关联的renderObject对象，其中后面的绘制与摆放都是renderObject控制
			abstruct class renderObject xx{
			void layout()
			void paint()
			}
	2. state
		stateLessWeight： 初始化参数控制显示 ， text源码
		stateFulWeight:	 响应变化，重新build， Image源码
	3. 生命周期
		state生命周期：
			创建：start -> 构造方法 -> initState -> didchangeDependencies -> build 
			更新：setState / didchangeDependencies（state变化） / didUpdateWidget（weight变化调用） -> 
			销毁：tree -> deactivate -> dispose -> end
		app生命周期：
			widgetBIndingObserver类具备很多接口回调
			resumed -> inactive -> paused : 前后台切换中间必定经过inactive
		帧回调：
			widgetsBinding.addPostFrameCallback : 回调一次
			widgetsBinding.addPersistentFrameCallback: 回调多次
	4. 基础控件
		1. 文字
			布局： 
				textalign 布局对齐
				textdirection 排版方向
				maxlines 最大行
				overflow 文本截断
			样式: 
				fontFamily 字体名称
				fontSize 字体大小
				color 字体颜色
				shadows 字体阴影
			text 单文字
			textSpan 分片
		2. 图片
			Image
			FadeInImage 支持占位，动画(需要添加transparent_image依赖)
			cachedNetworkImage 支持磁盘缓存
				
				fit 对其规则
				BoxFit.contain/scaleDown/contain/none
		3. 按钮
			floatingActionButton  圆形按钮
			FlatButton  扁平按钮
			RaisedButton  凸起按钮
				shape 	
					BeveledRectangleBorder 带斜角的长方形边框
					RoundedRectangleBorder 圆角矩形
					StadiumBorder 两端是半圆的边框
					CircleBorder 圆形
						side 用来设置边线（颜色，宽度等）
						borderRadius 用来设置圆角 
				enable/disable 通过onPressed是否为null决定
		4. 列表
			ListView
				listTitle 小组件单元
			ListView.Builder 适用于子weight较多的情况
				itemCount 元素个数
				itemExtent 列表高度
			ListView.separated 设置分割线，与ListView.Builder类似

			CustomScrollView 处理多个滚动效果的weight
				AppBar -> SliverAppBar
							floating 设置悬浮样式
							flexibleSpace 悬浮背景
				ListView -> SliverList
							delegate -> SliverChildBuilderDelegate 列表项
			ScrollController
				具体添加位置在：ListView.builder(
					controller: -> 
				)
				addListener
				dispose
			ScrollNotification
				具体添加位置在：child: ListView.builder
				scrollStartNotification
				scrollUpdateNotification
				scrollEndNotification
	5. 容器控件
		1. 单子weight布局
			container
				padding
				margin
			padding 单独设置一个内边距
			center 居中
			transform 旋转规则
			decoration 边框
			constraints 基本属性，设置宽高颜色等
		2. 多子weight布局
			Row 水平，行排列
			Column 垂直，列排列
			Expanded 剩余补全
				flex 分配比例

			对齐规则：
				mainAxisAlignment 横向 
					start/center/end/spaceEvenly（固定间距对齐）/spaceBetween（前后到底）/spaceAround（均分）
				crossAxisAlignment 纵向
			对齐负责：
				mainAxisSize 对齐规则
					min -> 等效wrap_content
					max -> 等效于match_parent
		3. 层叠weight布局
			stack 层叠布局
				positioned 设置子weight位置的
	6. 组合和自绘
		组合 拆解布局然后定义为一个组件
		自绘 
			xx extend customPaint{
				paint(canvas){
					drawLine
					drawRect
					drawPoint
					drawPath
					drawCircle
					drawArc
				}
			}
	7. 夜间模式
		主要是themeData控制
			brightness 明暗模式
			primaryColor 主色调
			accentColor 次色调
			fontFamily 文本字体
			cursorColor 光标颜色
		全局主题：MaterialApp控制
		局部主题：
			Theme(data:ThemeData(iconThemedata)) // 新建一个主题
			Theme(data:Theme.of(context).copyWith(x)) // 更新部分主题, theme.of(Context) 获取到上层weight的theme
		分平台定制主题
			TargetPlatform.ios? iosTheme :AndroidTheme
	8. 依赖管理
		pubspec.yaml 职责：主要是管理资源和依赖，比如第三方库，dart运行环境，flutter sdk版本等
		资源管理
			资源放入目录：assets
			声明在配置文件中
			flutter:
				assets:
					- assets/
					- assets/icons
			加载方式： rootBundle.load(二进制文件)/loadString(字符串资源)

			如果是有几倍图的情况：
			资源目录：
			assets
				back.jpg
				2.0x - back.jpg
			声明1倍图资源就可，flutter会自动去加载分辨率最近的资源
		字体
			资源放入目录：assets/fonts
			声明
				fonts:
					- family:xxx
					  font:
					   - assets:asset/fonts/xx
					   style:xx
					   wight:100
		原生平台的资源，直接去修改原生代码目录即可

	9. 事件
		1. 原始指针事件
			Listener（
			onPointerDown：
			onPointerMove：
			onPointerUp
			）
		2. 手势事件
			GestureDetector（
			onTap：
			onDoubleTap：
			onLongPress：
			onPanUpdate： // 拖动回调
			）
		3. 父子手势拦截 RawGestureDetector
		eg:【让父控件也能获取到手势】
			MultipleTapGestureRecognizer extends TapGestureRecognizer{
				rejectGesture()
			}
			RawGestureDetector(//自己构造父Widget的手势识别映射关系
 		 	gestures: {
  		  	//建立多手势识别器与手势识别工厂类的映射关系，从而返回可以响应该手势的recognizer
    			MultipleTapGestureRecognizer: GestureRecognizerFactoryWithHandlers<
    		   	 MultipleTapGestureRecognizer>(
    		     	 () => MultipleTapGestureRecognizer(),
    		     	 (MultipleTapGestureRecognizer instance) {
   		   	  instance.onTap = () => print('parent tapped ');//点击回调
  		   	 },
  		 	 )
 			 },
  			child：xxx(
			GestureDetector:xxx
			)
 			 ),
			);
	10. 数据交互
		InheritedWidget【父控件到子控件】
			子类继承InheritedWidget，实现updateShouldNotify，并提供of方法，
			可以达到类似Theme.of，通过主题子控件获取到父控件属性

		Notification
			父控件NotificationListener包裹，子控件使用 继承Notification的子类方法.dispatch分发
	
		EventBus
			eventBus.on().listen((event) { setState(() {
			xxx
			});
			
			eventBus.fire(xxx)
	11. 路由跳转
		主要由Route和navigator管理，其中路由的管理分为2种方式：
		1. 基本路由
			Navigator.push(xxx, MaterialPageRoute(builder: (context) => xxx()); // 跳转
			Navigator.pop(context) // 回退
			
		2. 命名路由
			MaterialApp(
				routes:{ "aaa":(context)=>xx(), },
				onUnknownRoute： //错误路由处理
			); // MaterialApp注册路由
			Navigator.pushNamed(context,"aaa"); // 跳转
			
			Navigator.of(context).pushNamed("aaa", arguments: "xx"); // 跳转传参
			String xx = ModalRoute.of(context).settings.arguments as String; // 获取参数
			
			Navigator.pushNamed(context, "aaa",arguments: "xx").then((msg)=>setState(()=>_msg=msg)) // 跳转监听返回
			Navigator.pop(context,"xx") // 返回传参 
五.	flutter进阶
	1. 动画
		
	2. 单线程模型
		event Loop机制
			dart是单线程的，与异步并不冲突，通过event Loop交互
		异步任务 （Future）
			有2个队列，一个事件队列Event Queue，一个微任务队列Microtask Queue,执行顺序：微任务队列 -> 事件队列
			微任务队列：手势识别，文本输入，滚动视图，保持页面效果等
			事件队列：io,绘制，定时器等

			then与Future公用一个事件循环，执行顺序： 事件对垒 -> then事件
		异步函数
			如果调用需要同步等待，则:
			async{
				(await futurex()) // futurex为future函数
			}
		多线程并发 (ioslate)
			Isolate.spawn(fun(),"msg") 执行一个并发任务

			并发任务之间的消息通讯，需要使用ReceivePort来解决
			并发计算任务可以采用 compute函数执行
				swait compute(funx(),value)
	3. http网络编程与json解析
		1. http网络编程
			httpClient(dart:io)
				async{
					httpClient=new httpClient
					httpClient.idleTimeout // 超时
					request=await httpClient.getUrl() // 设置url
					response=await request.close // 发送请求
					if(response.statusCode==HttpStatus.ok) // 收到响应
				}
				所有的请求使用Future包装async外包装，请求位置若需要同步等待，则使用swait。
			http（dart原生）
				dependencies{
					http : '>=0.11.3+12'
				}
				saync{
					client=new http.client
					response=swait client.get(url,header) // 设置url并请求
					if(response.statusCode==HttpStatus.ok) // 收到响应
					{
						response.body
					}
				}
			dio(三方库) 
				dependencies{
					dio : '>2.1.3'
				}
				saync{
					dio=new dio
					response=swait dio.get(url,options) // 设置url并请求
					if(response.statusCode==HttpStatus.ok) // 收到响应
					{
						response.date.toString
					}
					// 上传文件  
					formData=FormData.from()
					response=swait dio.post(url,formData)
					// 下载文件
					dio.download(url,"x.zip")
					// 多请求
					List<response> response=Future.wait()[dio.get,dio.get]
					// 拦截器
					dio.interceptors.add()
					// 异常捕获
					try{
					response=swait dio.get(url,options)
					}catch(e)
				}
		2. Json解析
			json.decode("json") // 返回Map<String,dynamic>类型

			在数据量计算很大的情况下，可使用isolate优化，如下：
				compute（funx(),"json"）.then(print(xx))
	4. 本地存储与数据库
		1. 文件
			目录有2个：
				1. temporaryDirectory 等效于cacheDir
				2. Documentirectory 等效于appData
			async{
				dir=await getApplicationDocumentirectory() //	获取文件目录
				file(dir/xxx.txt).writeAsString	// 写
				file(dir/xxx.txt).readAsString	// 读
			}
		2. sharedPreferences
			async{
				preference=await getSharepreference.getInstance()
				preference.getInt('x')
				preference.setInt('x')
			}
		3. 数据库
			async{
				db=await openDatabase(join(await getDataBasePath,"x.db"),
					onCreate: => db.execute
					onUpdate => 
					version:1
				)
				await db.insert('x',"xx",conflictAlgorithm:ConflictAlgorithm.replace) // 插入
				List list=await db.query('x'）
				db.close
			}
	5. 兼容android/ios平台
		调用底层方法主要依赖于method channel
		1. method channel [flutter控制原生响应]
		flutter:
		const platform = MethodChannel('');
		fun() async{
			try{
				result= await platform.invorkMethod('')
			}catch(e)
		}
		原生侧：
		new MethodChannel(getFlutterView(),'').setMethodCallHandler{
			onMethodCall(){
				call.method.equals(''){
					result.success/error
				}
			}
		}
		2. 安卓的view显示在flutter中
		flutter:
		viewFactory extends platformViewFactory{
			platformView create 
		}
		viewControl implements platformView{
			getview
			dispose
		}
		Register register =registarFor('')
		viewFactory factory=new ViewFactory(register.messenger())
		register.platformViewRegistry()

		如果想动态的调整，就需要参数传递  [flutter控制原生响应]
		通过method channel的方式传递数据
	6. 混编flutter工程
		flutter作为原生的aar工程

		添加flutter library
			打包aar, flutter build apk --debug
			添加依赖
			配置使用，setContentView(Flutter.createView(this,getLifecycle,"defaultRoute"))

	7. 导航栈管理
		原生页面与flutter页面互相切换

	8. 状态管理
		Provider【共享数据】
		添加依赖：provider: 3.0.0+1 #provider依赖
		1. ChangeNotifier【单资源】
		xxxModel with ChangeNotifier{
			get
			set(){
				notifyListeners()
			}
		}
		使用：
			在控件的父控件套一层 ChangeNotifierProvider.value(）
		读：
			final xxx = Provider.of<xxxModel>(context);	
		写：
			final xxx = Provider.of<xxxModel>(context);
			xxx.set()
		
		缺点：
			调用get/set会所有地方的控件都刷新，为了解决此问题，引入Consumer，在每个get/set位置使用Consumer包裹
			Consumer(
				builder: (context, xxxModel xx, child) =>xxx) // 其中仅更新model,child不重建
				);
		2. MultiProvider【多资源】
		设置
			MultiProvider(providers: [
				Provider.value()
				ChangeNotifierProvider.value(value: CounterModel()) //注入计数器实例
			]
		读
			Provider.of<xxModel>(context)
			Consumer2<xxxModel,double>(
				builder: (context, xxxModel counter, double textSize, _) => 
			)
	9. 推送
		极光推送插件
		1. 初始化极光sdk
		2. 获取地址id
		3. 注册消息通知
	
	10. 多语言适配
			Flutter i18n插件
			添加依赖
				 flutter_localizations:
    			sdk: flutter
			
	11. 分辨率适配
		适配屏幕旋转
			OrientationBuilder // OrientationBuilder的builder模式感知屏幕旋转
			MediaQuery.of(context).orientation
			SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp]); //固定屏幕
		适配平板电脑【屏幕空间划分为多个窗格，类似Fragment/ChildViewController来抽象独立区块】
			if(MediaQuery.of(context).size.width > 480) { 【假设平板宽度大于 480】
 			 	//tablet
			} else {
  				//phone
			}
	12. 编译模式
		flutter的编译模式
			Debug:
				JIT 模式,支持真机/模拟器运行，打开所有的断言assert，调试信息、服务扩展和调试辅助Observatory,热重载，无优化代码执行速度、二进制包大小和部署，flutter run --debug
			Release:
				AOT 模式,只能真机运行,优化了应用快速启动、代码快速执行，以及二级制包大小,flutter run --release
			Profile:
				与 Release 模式一致,多了对 Profile 模式的服务扩展的支持，包括支持跟踪，以及一些为了最低限度支持所需要的依赖（连接 Observatory 到进程）,flutter run --profile
		编译模式的识别
			assert
			通过在不同编译环境添加的变量
		分离配置环境
			flutter run apk/ios -t lib/main_dev.dart 
			flutter run apk/ios -t lib/main.dart
			或者在Edit Configurations里面配置不同的编译选项，+，flutter，dartEntryPoint
			
	13. hot reload原理

	14. 优化调试效率
		输出日志
			debugPrint = (String message, {int wrapWidth}) {}; // debug环境
			debugPrint = (String message, {int wrapWidth}) => debugPrintSynchronously(message, wrapWidth: wrapWidth);// release环境
		断点调试
		布局调试
			1> 界面调试工具
			void main() {
				...
				debugPaintSizeEnabled = true; // 开启布局调试
				runApp(...)
			}
			2> Flutter Inspector
	15. 检测优化flutter性能
		
	16. 自动化测试

六.	flutter综合
	1. 异常捕获
		1> app层异常捕获
		同步异常：try{}catch(e){print(e)}
		异步异常：Future.xxx.catchError((e)=>print(e))
			同步无法捕获异常异常，如果想捕获，等待异步结果，捕获同步代码
			try{
				await Future.xxx.catchError()
			}catch ...
		2> framework异常的捕获方式
		//框架异常
   		 FlutterError.onError = (FlutterErrorDetails details) async {
    		  //线上环境，走上报逻辑
     		 if (isRelease) { // 将框架异常转发到当前的 Zone 中
     		   Zone.current.handleUncaughtError(details.exception, details.stack);
     		 } else {
     		   //开发期间，走Console抛出
    		    FlutterError.dumpErrorToConsole(details);
    		  }
   		 };
   		 runZoned>(() async { // 全局捕获异常
		 	runApp(MyApp());
		 }, onError: (error, stackTrace) async { 
		 //Do sth for error
		 });
		3> 第三方
		bugly ,仅使用其上报功能
		注意：
			配置权限
			解决Android P 默认限制 http 明文传输数据，配置network_security_config
		4> Engine层异常
		可使用bugly去捕获
		
	2. 线上质量指标
		页面异常率
			页面异常率 = 异常发生次数 / 整体页面 PV 数
			异常发生次数：在全局异常上报位统计
			整体页面 PV 数：页面显示次数，NavigatorObserver观察者监听页面关闭次数，统计
		页面帧率
			

		页面加载时长
		
	3. 组件化

	4. 打包环境优化

	5. 构建混合开发框架
		