一.	原理分析
	1.	KOOM初始化流程：
		开启了一个handlerThread去check有无未完成的hporf文件，如果有就触发解析，没有就监控内存，KOOMInternal

	2.	heap dump流程
		监控Manager：MonitorManager中开启HandlerThread监控线程，5s检测一次是否超过阀值，超过3次就触发dump,执行HeapDumpTrigger.trigger流程，
		dump hprof：fork子进程处理，完成之后触发回调HeapAnalysisTriggerstartTrack执行heap分析流程
		其中具体的dump是jni层做的 fork子进程，dump文件解决dump耗时问题

	3.	heap analysis流程
		HeapAnalysisTrigger.startTrack触发hprof文件分析
		trigger触发的文件分析是单独进程service处理，主要检测内存泄露（activity/fragment/bitmap/window）和泄露数据整理缓存为json文件上报
			activity: 反射属性 mFinished,mDestroyed为true,实例还存在的Activity，就是泄露对象
			fragment: FragmentManager实例为null(fragment remove了),反射属性 mFragmentManager 判断 mCalled为true,就说明非perform状态，生命周期被回调，但是实列还存在就泄露
			bitmap: bitmap的widthxheight>768x1366
			nativeAllocationRegistry: 直接+1，暂时不参与对象泄露检测
			window: 直接+1，不参与对象泄露检测

二.	重点流程分析
	1.	内存监控触发dump规则
	HeapMonitor.isTrigger:	5s循环检测，内部内存判断，超高3次最大内存80%（不同内存大小阀值不同）比例，且上升就触发dump

	2.	fork进程执行dump
	ForkJvmHeapDumper.dump:	
	  int pid = trySuspendVMThenFork(); // 暂停虚拟机，copy-on-write，fork子进程	
      if (pid == 0) {	// 子进程
        Debug.dumpHprofData(path);	// dump hprof
        exitProcess(); // 退出进程
      } else {	// 父进程
        resumeVM();	// resume当前虚拟机
        dumpRes = waitDumping(pid);	// waitpid异步等待pid进程结束
      }
     自研kwai-linker，caller address替换和dl_iterate_phdr解析绕过android7.0对系统调用库的限制

     3.	内存泄露检测实现
     SuspicionLeaksFinder.find:
		buildIndex:	
			将Hrpof文件按照扫描的格式解析为结构化的索引关系图,索引化后的内容封装为HprofHeapGraph,由它去通过对应的起始索引去定位每类数据,(copy from squere HAHA)
		initLeakDetectors:
			初始化Activity，Fragment，Bitmap+NativeAllocationRegistry，window
		findLeaks:
			检测泄露类及其子类有无满足泄露条件，把泄露的类添加进json

三.	优点
	1.	内存泄露检测
		轮训查询是否到达峰值
	2.	dump pref 
		开辟单独进程dump

四.	同类
	tailor: 获取内存快照工具，并进行裁剪压缩操作
		对内存hprof文件的裁剪库，根据hprof文件格式，去除了一些无用的格式，仅保留byte[]、char[] 和 hprof 格式裁剪
		xHook native hook dump的时候必定会执行open/write函数，对此hook实现dump之后的裁剪操作，并实现zlib压缩，
		其中一个环节裁剪流程：
			nOpen（）：开启对native 层open/write_proxy的hook代理
			Debug.dumpHprofData()：调用open，hook代理里面找到目标文件fd，write的时候找到目标fd写入数据并裁减压缩
			nClose（）：清除hook代理

	matrix:
		Debug.dumpHprofData直接dump完整hprof文件，分析hprof文件格式，裁剪掉数据相同的 Bitmap 对象和 String 对象
		问题点： 
			hprof文件较大，无法存储
			裁剪中的大文件 I/O 和 hprof 分析，对app性能有影响
			裁剪不彻底，存在大量无用数据和可能存在的隐私问题

	拓展（hprof格式）：
		由 Header和 Record 组成 
		1.	Header
			"JAVA PROFILE 1.0.2" + indetifiers + timestamp (13byte + 4byte + 8byte)
		2.	Record 
			tag + time + length + body（1byte + 4byte + 4byte + byte[$length]）
		android dump出来的hprof文件也遵循 hprof 格式，不同之处在于其一级TAG只有：
			STRING、LOAD_CLASS、HPROF_TAG_STACK_TRACE、HEAP_DUMP_SEGMENT、HEAP_DUMP_END。
		HEAP_DUMP_SEGMENT又分很多二级tag，既有标准 hprof 定义，也有Android 自定义的 TAG，跟裁剪关系比较
		紧密的二级 TAG 是 PRIMITIVE_ARRAY_DUMP，存放的是诸如 byte[] 、char[] 、int[]等类型的数据

		裁剪 byte[]和 char[]就可以实现对 Bitmap/String 对象的裁剪，无用数据有timestamp、class-serial-number、
		stack-serial-number、reserved 数据等等，4byte 的 length/number也可以压缩3byte/2byte



